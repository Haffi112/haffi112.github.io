<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Hafsteinn</title>
 <link href="http://haffi112.github.io/atom.xml" rel="self"/>
 <link href="http://haffi112.github.io/"/>
 <updated>2018-07-13T15:52:35+00:00</updated>
 <id>http://haffi112.github.io</id>
 <author>
   <name>Hafsteinn Einarsson</name>
   <email>haffie@gmail.com</email>
 </author>

 
 <entry>
   <title>Leaky integrate and fire neurons (LIF)</title>
   <link href="http://haffi112.github.io/2016/05/15/lif-neuron/"/>
   <updated>2016-05-15T00:00:00+00:00</updated>
   <id>http://haffi112.github.io/2016/05/15/lif-neuron</id>
   <content type="html">&lt;p class=&quot;message&quot;&gt;
This post assumes basic understanding of neurons. For a short
introduction to neurons please see &lt;a href=&quot;https://simple.wikipedia.org/wiki/Neuron&quot;&gt;this&lt;/a&gt; Wikipedia
article.
&lt;/p&gt;

&lt;p&gt;There are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Biological_neuron_model&quot;&gt;multiple&lt;/a&gt;
existing models for biological neurons, some which even contradict each
other. In this post we explore the &lt;em&gt;leaky-integrate and fire&lt;/em&gt; neuron
model (LIF) which is commonly used in simulations which mimic neural
networks found in the brain. It has the advantage of being simple while
also capturing the large scale dynamics of how a single neuron
functions.&lt;/p&gt;

&lt;p&gt;Note that not all of the cells in our brains &lt;em&gt;spike&lt;/em&gt; (i.e.
transmit digital signals) and behave like the one we discuss below. Most
of the cells which we call neurons do spike however. It is commonly
acknowledged that the signals they send amongst themselves form the
basis of information dissemination and computation in the brain.&lt;/p&gt;

&lt;p&gt;The LIF neuron corresponds to what is called a &lt;em&gt;membrane voltage&lt;/em&gt; model.
It is inspired by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Squid_giant_axon&quot;&gt;experiments&lt;/a&gt;, first
carried out by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Alan_Lloyd_Hodgkin&quot;&gt;Hodgin&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Andrew_Huxley&quot;&gt;Huxley&lt;/a&gt; in the 1950s &lt;a href=&quot;#hodgkin1952quantitative&quot;&gt;(Hodgkin &amp;amp; Huxley, 1952)&lt;/a&gt;, which measure the voltage difference
inside and outside a neuron. The model is quite simple, we can give some
input to the neuron, in the form of an electrical current, and we can
observe how the voltage across the membrane changes over time.&lt;/p&gt;

&lt;p&gt;Before the experiments of Hodgin and Huxley the &lt;em&gt;integrate-and-fire&lt;/em&gt;
neuron model (note that the &lt;em&gt;leaky&lt;/em&gt; part is missing) had already been
proposed. It is in fact a variant of the model we have used in the
previous posts on &lt;a href=&quot;/2016/04/25/percolation-with-inhibition/&quot;&gt;bootstrap percolation&lt;/a&gt;. In that model a neuron never
&lt;em&gt;forgets&lt;/em&gt; the input it received in the past. If it requires two input
spikes in order to spike itself it is even allowed that these two spikes
come a year apart from each other. In reality this is a different story
and any trace of the first spike would vanish a few milliseconds later.
Note however that integrate-and-fire models are still useful, for
example when modelling phenomena which occurs at a very short timescale.&lt;/p&gt;

&lt;p&gt;The fact that neurons forget old spikes corresponds to the &lt;em&gt;leaky&lt;/em&gt; part
in the name. You can think of a neuron as a bucket. When it receives
input a bit of water gets added to the bucket. When the bucket is full
it spikes and that spike corresponds to adding a bit of water to all the
neighbouring buckets. However, there is a catch, the bucket has a hole
in the bottom so the water leaks out.&lt;/p&gt;

&lt;p&gt;If you want to skip the math part now is the time to scroll down to the
bottom to see a live, interactive simulation of a LIF neuron.&lt;/p&gt;

&lt;p&gt;The water level in the bucket corresponds to the membrane voltage of the
neuron. The neuron prefers to be a bit polarised and its &lt;em&gt;resting
potential&lt;/em&gt; (corresponding to an empty bucket) is at around &lt;script type=&quot;math/tex&quot;&gt;-70&lt;/script&gt; mV.
Whenever the neuron receives an input spike some channels will open on
the membrane and ions will flow through which depolarises the neuron.
The neuron has some ion pumps on the membrane which actively pump these
ions back out which corresponds to the &lt;em&gt;leak&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since the membrane voltage changes over time we can model it using a
differential equation. Such an equation tells us how the membrane
voltage changes in one moment. We denote the voltage at time &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; by
&lt;script type=&quot;math/tex&quot;&gt;V(t)&lt;/script&gt; and we denote the resting potential by &lt;script type=&quot;math/tex&quot;&gt;E_L&lt;/script&gt; (also known as the
&lt;em&gt;leak reversal potential&lt;/em&gt;). Additionally we denote the input to the
neuron at time &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;g_e(t)&lt;/script&gt; and the excitatory reversal potential
by &lt;script type=&quot;math/tex&quot;&gt;E_E&lt;/script&gt; which is the membrane voltage which the input is driving the
neuron towards.&lt;/p&gt;

&lt;p&gt;For a short time interval &lt;script type=&quot;math/tex&quot;&gt;\Delta t&lt;/script&gt; the voltage changes as follows&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
V(t+\Delta t) =&amp; V(t)\\&amp; - \Delta t \cdot A\cdot g_L\cdot (V(t)-E_L) \\
&amp;- \Delta t\cdot B \cdot g_e(t)\cdot (V(t)-E_E)
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; are positive constants. So you see that on the one
hand the voltage, &lt;script type=&quot;math/tex&quot;&gt;V(t)&lt;/script&gt; is drawn towards &lt;script type=&quot;math/tex&quot;&gt;E_L&lt;/script&gt; via the constant
leak and on the other hand it is drawn towards &lt;script type=&quot;math/tex&quot;&gt;E_E&lt;/script&gt; via the input
current (here modelled as conductance). One popular approach to model
the input conductance is via exponential decay, the conductance then
simply behaves as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
g_e(t+\Delta t) =&amp; g_e(t) -\Delta t\cdot C\cdot g_e(t)
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is also some positive constant. We additionally increase
&lt;script type=&quot;math/tex&quot;&gt;g_e(t)&lt;/script&gt; by some value &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; whenver the neuron receives an input
where &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; corresponds to the weight of the incoming synapse. This
still does not capture how the neuron spikes. As in the
integrate-and-fire model it just needs to cross some threshold, which we
denote by &lt;script type=&quot;math/tex&quot;&gt;V_{th}&lt;/script&gt;. So whenever &lt;script type=&quot;math/tex&quot;&gt;V(t)&lt;/script&gt; exceeds &lt;script type=&quot;math/tex&quot;&gt;V_{th}&lt;/script&gt; the neuron
emits a spike. Following the spike the neuron enters a &lt;em&gt;refractory
period&lt;/em&gt; where it ignores all incoming spikes. After that period the
membrane voltage is reset to a fixed value, denoted by
&lt;script type=&quot;math/tex&quot;&gt;V_{\text{reset}}&lt;/script&gt; which is called the &lt;em&gt;reset potential&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Below you can see an interactive simulation of a LIF neuron following
the dynamics described above. You can press the input neuron on the left
to send a spike to the output neuron on the right. You can visualise the
membrane potential of the target neuron via the radius of the circle
representing it. The dynamics of the membrane potential are 100 times
slower than in reality (otherwise you would not see much happening) and
the parameters as seen above are set to somewhat realistic values. Note
however that the time to deliver the spike between the two neurons and
the time in the refractory period is exaggarated for demonstration
purposes. If you want to run large scale simulations using this type of
neuron you can do so using the
&lt;a href=&quot;http://www.nest-initiative.org/&quot;&gt;nest-simulator&lt;/a&gt; and the
&lt;a href=&quot;https://github.com/nest/nest-simulator/blob/master/models/iaf_cond_exp.cpp&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathtt{iaf\_cond\_exp}&lt;/script&gt;&lt;/a&gt;
neuron model &lt;a href=&quot;#meffin2004analytical&quot;&gt;(Meffin, Burkitt, &amp;amp; Grayden, 2004)&lt;/a&gt; where the parameters are
from.&lt;/p&gt;

&lt;div id=&quot;neuron&quot;&gt;&lt;/div&gt;

&lt;script&gt;
var width = d3.select(&quot;#neuron&quot;).node().getBoundingClientRect().width;
var height = 300;
var delay = 250;
var neuronradius = 15;
var msgradius = 5;

var m_V = -70.0E-3; // Membrane voltage
var g_E = 0.0; // Excitatory synaptic conductance
var t_delta = 1E-4; // 0.1 ms, so we need to update every 10 ms

var spike_effect = 1.0E-3;
var membrane_capacitance = 250E-12; // Capacity of the membrance
var E_E= 0.0; // Excitatory reversal potential
var E_L = -70E-3;   // Leak reversal potential
var g_L = 16.6667E-9; // Leak conductance, nS
var V_T = -55E-3    // Threshold potential
var V_reset = -60E-3 // Reset potential
var t_ref = 2.5E-3 // Refractory period
var weight = 1E-7;
var t_syn = 0.2E-3;

var realTimeDelay = 10;
var realTimeRefractoryPeriod = 1000;

var started = false;
var spiking = false;
var blowup = 3000;

var thresholdradius = neuronradius + (V_T - E_L)*blowup;
var resetradius = neuronradius + (V_reset-E_L)*blowup;

var fill = d3.scale.category20c();


var svg = d3.select(&quot;#neuron&quot;).append(&quot;svg&quot;)
    .attr(&quot;width&quot;, width)
    .attr(&quot;height&quot;, height);

var play = svg.append(&quot;g&quot;)
    .attr(&quot;class&quot;, &quot;play&quot;);

play.append(&quot;circle&quot;)
    .attr(&quot;r&quot;, neuronradius)
    .attr(&quot;stroke-width&quot;, &quot;.5px&quot;)
    .attr(&quot;transform&quot;, &quot;translate(&quot; + width / 4 + &quot;,&quot; + height / 2 + &quot;)&quot;)
    .on(&quot;mousedown&quot;, function() {
      play.classed(&quot;mousedown&quot;, true);
      d3.select(window).on(&quot;mouseup&quot;, function() { play.classed(&quot;mousedown&quot;, false);
        // Input spike
        var input_spike = svg.append(&quot;circle&quot;);
        input_spike.attr({
            cx: width/4.0,
            cy: height/2.0,
            fill: fill.range()[8],
            r: neuronradius + (m_V-E_L)*blowup,
            opacity:1.0
          })
        input_spike.transition()
          .duration(150)
          .ease(&quot;linear&quot;) // For more easing info check http://bl.ocks.org/hunzy/9929724
          .attr(&quot;r&quot;,200)
          .attr(&quot;opacity&quot;,0)
          .remove();
        // Message
        var marker = svg.append(&quot;circle&quot;);
        marker.attr({
            cx: width/4.0,
            cy: height/2.0,
            fill: fill.range()[8],
            r: neuronradius,
            opacity:0.5
          })
        marker.transition()
          .duration(delay)
          .ease(&quot;circle&quot;) // For more easing info check http://bl.ocks.org/hunzy/9929724
          .attr(&quot;cx&quot;,3*width/4.0)
          .attr(&quot;r&quot;,msgradius)
          .each(&quot;end&quot;, function(){
            if(!spiking) {
              g_E += weight;
            }
            if(!started) {
              started=true;
              setTimeout(update,10);
            }
           })
          .remove();
      });
    })
    .on(&quot;click&quot;, function() {
      });

var neuron = svg.append(&quot;g&quot;)
  .attr(&quot;class&quot;, &quot;neuron&quot;);

var neuron_threshold = neuron.append(&quot;circle&quot;)
    .attr({fill:&quot;none&quot;,
        &quot;stroke-width&quot;:&quot;1.5px&quot;,
        stroke:&quot;#000&quot;,
        &quot;stroke-linejoin&quot;:&quot;round&quot;,
        &quot;opacity&quot;: 0.5,
        &quot;stroke-dasharray&quot;:&quot;10,10&quot;})
    .attr(&quot;r&quot;, neuronradius + (V_T - E_L)*blowup)
    .attr(&quot;transform&quot;, &quot;translate(&quot; + 3*width / 4 + &quot;,&quot; + height / 2 + &quot;)&quot;);

var neuron_reset = neuron.append(&quot;circle&quot;)
    .attr({fill:&quot;none&quot;,
        &quot;stroke-width&quot;:&quot;.5px&quot;,
        stroke:&quot;#000&quot;,
        &quot;stroke-linejoin&quot;:&quot;round&quot;})
    .attr(&quot;r&quot;, resetradius)
    .attr(&quot;transform&quot;, &quot;translate(&quot; + 3*width / 4 + &quot;,&quot; + height / 2 + &quot;)&quot;);

var neuroncircle = neuron.append(&quot;circle&quot;)
    .attr(&quot;r&quot;, neuronradius)
    .attr(&quot;fill&quot;,d3.rgb(fill.range()[8]).brighter((m_V-E_L)*150))
    .attr(&quot;transform&quot;, &quot;translate(&quot; + 3*width / 4 + &quot;,&quot; + height / 2 + &quot;)&quot;)
    .attr(&quot;opacity&quot;, 0.5);

function update() {
  spiking = false;
  //console.log(m_V);
  //console.log(g_E);
  g_E = g_E - (t_delta/t_syn)*g_E;
  m_V = m_V + (t_delta/membrane_capacitance)*( -g_L*(m_V - E_L) - g_E*(m_V - E_E));
  neuroncircle.transition().duration(0).attr(&quot;r&quot;,neuronradius + (m_V-E_L)*blowup)
  .attr(&quot;fill&quot;,d3.rgb(fill.range()[8]).brighter((m_V-E_L)*150));

  if(!spiking &amp;&amp; m_V &gt; V_T) {
    spiking = true;
    m_V = V_reset;
    neuroncircle.transition().duration(0)
      .attr(&quot;r&quot;,neuronradius + (m_V-E_L)*blowup)
      .attr(&quot;fill&quot;,fill.range()[4]);
    var marker = svg.append(&quot;circle&quot;);
    marker.attr({
        cx: 3*width/4.0,
        cy: height/2.0,
        fill: fill.range()[8],
        r: neuronradius + (m_V-E_L)*blowup,
        opacity:1.0
      })
    marker.transition()
      .duration(500)
      .ease(&quot;linear&quot;) // For more easing info check http://bl.ocks.org/hunzy/9929724
      .attr(&quot;r&quot;,200)
      .attr(&quot;opacity&quot;,0)
      .remove();
    setTimeout(update,realTimeRefractoryPeriod);
  }
  else if(m_V - E_L &lt; 0.0005) {
    started = false;
  }
  else {
    setTimeout(update,realTimeDelay);
  }
}

var arc_margin = 1.1;
var arc_margin2 = 1.05;

// Threshold label

//Create an SVG path
svg.append(&quot;path&quot;)
	.attr(&quot;id&quot;, &quot;threshold_radius_margin&quot;) //very important to give the path element a unique ID to reference later
	.attr(&quot;d&quot;, &quot;M &quot;+((3*width/4.0)-arc_margin*thresholdradius)+&quot;,&quot;+height/2.0+&quot; A &quot;+arc_margin*thresholdradius+&quot;,&quot;+arc_margin*thresholdradius+&quot; 0 0,1 &quot;+((3*width/4.0)+arc_margin*thresholdradius)+&quot;,&quot;+height/2.0+&quot;&quot;) //Notation for an SVG path, from bl.ocks.org/mbostock/2565344
	.style(&quot;fill&quot;, &quot;none&quot;);

//Create an SVG text element and append a textPath element
svg.append(&quot;text&quot;)
  .classed(&quot;unselectable&quot;,true)
  .append(&quot;textPath&quot;) //append a textPath to the text element
	.attr(&quot;xlink:href&quot;, &quot;#threshold_radius_margin&quot;) //place the ID of the path here
	.style(&quot;text-anchor&quot;,&quot;middle&quot;) //place the text halfway on the arc
	.attr(&quot;startOffset&quot;, &quot;50%&quot;)
  .text(&quot;Spiking threshold&quot;)
  .attr(&quot;font-size&quot;,14);

// Reset potential label
svg.append(&quot;path&quot;)
	.attr(&quot;id&quot;, &quot;reset_radius_margin&quot;) //very important to give the path element a unique ID to reference later
	.attr(&quot;d&quot;, &quot;M &quot;+((3*width/4.0)-arc_margin2*resetradius)+&quot;,&quot;+height/2.0+&quot; A &quot;+arc_margin2*resetradius+&quot;,&quot;+arc_margin2*resetradius+&quot; 0 0,1 &quot;+((3*width/4.0)+arc_margin2*resetradius)+&quot;,&quot;+height/2.0+&quot;&quot;) //Notation for an SVG path, from bl.ocks.org/mbostock/2565344
	.style(&quot;fill&quot;, &quot;none&quot;);

//Create an SVG text element and append a textPath element
svg.append(&quot;text&quot;)
  .classed(&quot;unselectable&quot;,true)
  .append(&quot;textPath&quot;) //append a textPath to the text element
	.attr(&quot;xlink:href&quot;, &quot;#reset_radius_margin&quot;) //place the ID of the path here
	.style(&quot;text-anchor&quot;,&quot;middle&quot;) //place the text halfway on the arc
	.attr(&quot;startOffset&quot;, &quot;50%&quot;)
  .text(&quot;Reset potential&quot;)
  .attr(&quot;font-size&quot;,11);

play.append(&quot;text&quot;).attr(&quot;text-anchor&quot;, &quot;middle&quot;)
  .attr(&quot;x&quot;,width/4.0)
  .attr(&quot;dy&quot;,4*height/5.0)
  .classed(&quot;unselectable&quot;,true)
  .text(&quot;Input neuron&quot;)
  .attr(&quot;font-size&quot;,14);

neuron.append(&quot;text&quot;).attr(&quot;text-anchor&quot;, &quot;middle&quot;)
  .attr(&quot;x&quot;,3*width/4.0)
  .attr(&quot;dy&quot;,4*height/5.0)
  .classed(&quot;unselectable&quot;,true)
  .text(&quot;Output neuron&quot;)
  .attr(&quot;font-size&quot;,14);

&lt;/script&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;hodgkin1952quantitative&quot;&gt;Hodgkin, A. L., &amp;amp; Huxley, A. F. (1952). A quantitative description of membrane current and its application to conduction and excitation in nerve. &lt;i&gt;The Journal of Physiology&lt;/i&gt;, &lt;i&gt;117&lt;/i&gt;(4), 500.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;meffin2004analytical&quot;&gt;Meffin, H., Burkitt, A. N., &amp;amp; Grayden, D. B. (2004). An analytical model for the ‘large, fluctuating synaptic conductance state’typical of neocortical neurons in vivo. &lt;i&gt;Journal of Computational Neuroscience&lt;/i&gt;, &lt;i&gt;16&lt;/i&gt;(2), 159–175.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Percolation with inhibition - part 2</title>
   <link href="http://haffi112.github.io/2016/04/29/percolation-with-inhibition-part2/"/>
   <updated>2016-04-29T00:00:00+00:00</updated>
   <id>http://haffi112.github.io/2016/04/29/percolation-with-inhibition-part2</id>
   <content type="html">&lt;p&gt;This part 2 in the series on percolation with inhbition. If you have not
yet read part 1 you can find it &lt;a href=&quot;/2016/04/25/percolation-with-inhibition/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post we will try to get an intuition for how many vertices
eventually turn active in the process. Let us assume that we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;
vertices in total, &lt;script type=&quot;math/tex&quot;&gt;n^+&lt;/script&gt; of them which send positive messages and
&lt;script type=&quot;math/tex&quot;&gt;n^-&lt;/script&gt; of them which send negative messages.&lt;/p&gt;

&lt;p&gt;For a fixed vertex in the graph we can assume that it does not know if
its neighbours are positive or negative. Since it only receives at most
one message from each neighbour we can think of these messages being
independently positive with probability &lt;script type=&quot;math/tex&quot;&gt;n^+/n&lt;/script&gt; and negative
with probability &lt;script type=&quot;math/tex&quot;&gt;n^-/n&lt;/script&gt;. Formally these events are not independent
but the dependence is weak so you can assume they are to get some
intuition behind the process.&lt;/p&gt;

&lt;p&gt;This allows us to model the process as a Markov chain. If you are
unfamiliar with Markov chains there is a great pictorial explanation
&lt;a href=&quot;http://setosa.io/blog/2014/07/26/markov-chains/&quot;&gt;here&lt;/a&gt;. Our Markov
chain consists of &lt;em&gt;infinitely&lt;/em&gt; many states which represent the potential
of our single vertex under consideration. The states are given by the
set &lt;script type=&quot;math/tex&quot;&gt;\{\ldots,-2,-1,0,1,2,\ldots,K\}&lt;/script&gt; and correspond to the value of
the potential of the vertex. Like all vertices which are not active at
the start it starts with its potential in state 0 and it can only stop
if it ever reaches state &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;. The transition probabilities are given
as the probability of increasing or decreasing the potential as
explained in the previous paragraph.&lt;/p&gt;

&lt;p&gt;Below you see an interactive version of the process. The fact that state
&lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; is an absorbing state is denoted by a self-loop. Since we do not
have space for infinitely many states the left-most state represents all
states smaller or equal to &lt;script type=&quot;math/tex&quot;&gt;-K&lt;/script&gt;. You can imagine the chain extending
infinitely to the left. Additionally we reset the process if it has not
finished after 10 steps (you can change this variable below). Note that
the process should always reach &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
n^-&lt;n^+ %]]&gt;&lt;/script&gt; with enough many
steps. However, if &lt;script type=&quot;math/tex&quot;&gt;n^- &gt; n^+&lt;/script&gt; we have a drift to the left. This means
that if the potential becomes too small there is hardly any chance that
it will be able to recover. Try it out by choosing &lt;script type=&quot;math/tex&quot;&gt;n^- = 100&lt;/script&gt; and
&lt;script type=&quot;math/tex&quot;&gt;n^+ = 50&lt;/script&gt; for example.&lt;/p&gt;

&lt;div id=&quot;chain&quot;&gt;&lt;/div&gt;

&lt;form onsubmit=&quot;change_params(); return false;&quot; style=&quot;margin-bottom:20px&quot;&gt;
  &lt;input type=&quot;button&quot; value=&quot;Update parameters&quot; onclick=&quot;change_params()&quot; /&gt;
  &lt;table style=&quot;max-width: 720px; font-size:75%; margin-bottom:10px&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;nodeCount&quot;&gt;Number of positive vertices&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;nodeCount&quot; type=&quot;text&quot; value=&quot;50&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;inodeCount&quot;&gt;Number of negative vertices &lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;inodeCount&quot; type=&quot;text&quot; value=&quot;50&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;maximumSteps&quot;&gt;Maximum number of steps&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;maximumSteps&quot; type=&quot;text&quot; value=&quot;10&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;kPerc&quot;&gt;Activation threshold (&lt;i&gt;K&lt;/i&gt;)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;kPerc&quot; type=&quot;text&quot; value=&quot;2&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;delay&quot;&gt;Animation speed, ms (lower is faster)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;delay&quot; type=&quot;text&quot; value=&quot;50&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
&lt;p&gt;Below you can see some statistics of the simulations of the Markov chain.
The histogram shows after how many steps the potential reached &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;.
Observe that for &lt;script type=&quot;math/tex&quot;&gt;n^-\gg n^+&lt;/script&gt; the most likely outcome is that the
process goes directly to &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;.&lt;/p&gt;
&lt;div id=&quot;hist&quot;&gt;&lt;/div&gt;
&lt;p&gt;The plot below shows which fraction of all the simulations ever reach
&lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; within the given number of steps. You can use it to estimate which
fraction of the vertices turn active in the bootstrap percolation
process. Just set the maximum number of steps in the Markov chain to the
average degree of the graph.&lt;/p&gt;

&lt;p&gt;By pressing the &lt;em&gt;update parameters&lt;/em&gt; button you start a new simulation
and draw a new curve. The old one is not lost however so you can compare
different parameters.&lt;/p&gt;
&lt;div id=&quot;stats&quot;&gt;&lt;/div&gt;

&lt;script&gt;

var width = d3.select(&quot;#chain&quot;).node().getBoundingClientRect().width;
var height = 200;
var kThresh = 3;
var stateRadius = 15;
var trial = 0;
var n_ex = 80;
var n_in = 65;
var max_steps = 10;
var speed = 50;
var data_point = 0;

var n = 40;
//var data = Array.apply(0, Array(n)).map(Number.prototype.valueOf,0);
var data = [];
var histogram_data = [];

var fill = d3.scale.category20c();


function setup(num_exp) {
  data = Array.apply(0, Array(n)).map(Number.prototype.valueOf,0);
  data = [];
  histogram_data = [];
  d3.select(&quot;#chain&quot;).selectAll(&quot;*&quot;).remove();
  d3.select(&quot;#hist&quot;).selectAll(&quot;*&quot;).remove();
  var margin = width/(2.4*kThresh);
  var svg = d3.select(&quot;#chain&quot;).append(&quot;svg&quot;)
      .attr(&quot;width&quot;, width)
      .attr(&quot;height&quot;, height);

  d3.select(window)
      .on(&quot;resize&quot;, function() {
        var targetWidth = d3.select(&quot;#chain&quot;).node().getBoundingClientRect().width;
        svg.attr(&quot;width&quot;, targetWidth);
        });

  defs = svg.append(&quot;defs&quot;);

  defs.append(&quot;marker&quot;)
      .attr({
        &quot;id&quot;:&quot;arrow&quot;,
        &quot;viewBox&quot;:&quot;0 -5 10 10&quot;,
        &quot;refX&quot;:5,
        &quot;refY&quot;:0,
        &quot;markerWidth&quot;:4,
        &quot;markerHeight&quot;:4,
        &quot;orient&quot;:&quot;auto&quot;
      })
      .append(&quot;path&quot;)
        .attr(&quot;d&quot;, &quot;M0,-5L10,0L0,5&quot;)
        .attr(&quot;class&quot;,&quot;arrowHead&quot;);

  var path_collection = [];

  var xs = [], ys = [];
  for(var x = 0; x &lt;= 2*kThresh; ++x) {
    if(kThresh &lt; 3) {
      xs.push(margin + x*0.8*(margin));
    }
    else {
      xs.push(margin + x*0.8*(margin));
    }
    ys.push(height/2.0);
    path_collection.push({});
  }

  var forward = [], backward = [];
  for(var idx=0; idx &lt; xs.length-1; ++idx) {
    var coord=[[xs[idx],ys[idx]],[0.5*(xs[idx]+xs[idx+1])-10,ys[idx]-30],[xs[idx+1]-stateRadius,ys[idx+1]-stateRadius]];
    forward.push(coord);
    if(idx &lt; xs.length-2) {
      var clone=[[xs[idx+1],ys[idx+1]],[0.5*(xs[idx]+xs[idx+1])+10,ys[idx]+30],[xs[idx]+stateRadius,ys[idx]+stateRadius]];
      backward.push(clone);
    }
    else {
    var clone=[[xs[idx+1],ys[idx+1]],
      [xs[idx+1]+40,ys[idx]-30],
      [xs[idx+1]+50,ys[idx]],
      [xs[idx+1]+40,ys[idx]+30],
      [xs[idx+1]+20,ys[idx+1]+stateRadius]];
      backward.push(clone);
    }
  }

  for(var idx=0; idx &lt; forward.length; ++idx) {
    var path = svg.append(&quot;path&quot;)
      .data([forward[idx]])
      .attr(&quot;d&quot;, d3.svg.line()
        .tension(0) // Catmull–Rom
        .interpolate(&quot;basis&quot;))
      .attr({
        &quot;class&quot;:&quot;arrow&quot;,
        &quot;marker-end&quot;:&quot;url(#arrow)&quot;
        });
    path_collection[idx][&quot;forward&quot;] = path;
    var path2 = svg.append(&quot;path&quot;)
      .data([backward[idx]])
      .attr(&quot;d&quot;, d3.svg.line()
        .tension(0) // Catmull–Rom
        .interpolate(&quot;basis&quot;))
      .attr({
        &quot;class&quot;:&quot;arrow&quot;,
        &quot;marker-end&quot;:&quot;url(#arrow)&quot;
        });
    path_collection[idx+1][&quot;backward&quot;] = path2;
  }

  var states = {&quot;nodes&quot;:[]};
  for(var idx=0; idx &lt; xs.length; ++idx) {
    var fillcolor;
    if(idx &gt; kThresh) {
        fillcolor =  d3.rgb(fill.range()[8]).brighter(idx-kThresh-2);
        }
        else if(idx == kThresh) {
          fillcolor = fill.range()[17];
        }
        else {
          fillcolor = d3.rgb(fill.range()[0]).darker(kThresh - idx - 2);
        }
    var state = {&quot;x&quot;: xs[idx], &quot;y&quot;: ys[idx], &quot;r&quot;: stateRadius, &quot;fill&quot;:
    fillcolor, &quot;label&quot;:idx-kThresh, &quot;coord&quot;:[xs[idx],ys[idx]]};
    states[&quot;nodes&quot;].push(state);
    path_collection[idx][&quot;node&quot;] = state;
  }

  var elem = svg.selectAll(&quot;g&quot;).data(states.nodes);
  var elemEnter = elem.enter()
    .append(&quot;g&quot;)
    .attr(&quot;transform&quot;, function(d){return &quot;translate(&quot;+d.x+&quot;,&quot;+d.y+&quot;)&quot;});
  var circle = elemEnter.append(&quot;circle&quot;)
    .attr(&quot;r&quot;, function(d){return d.r})
    .attr(&quot;fill&quot;, function(d) {return d.fill});
  var labels = elemEnter.append(&quot;text&quot;)
    .attr(&quot;dx&quot;, function(d){
      if(d.label &lt; 0) {return -stateRadius/2.0}
      else {return -stateRadius/2.0 + 3.0}
    })
    .attr(&quot;dy&quot;, function(d){return 5})
    .attr(&quot;font-size&quot;, &quot;14px&quot;)
    .attr(&quot;fill&quot;, fill.range()[19])
    .text(function(d){return d.label});

  var circle = svg.append(&quot;circle&quot;)
      .attr(&quot;r&quot;, 13)
      .attr(&quot;opacity&quot;,0.5)
      .attr(&quot;transform&quot;, &quot;translate(&quot; + path_collection[kThresh][&quot;node&quot;][&quot;coord&quot;] + &quot;)&quot;);

  var prob_win = svg.append(&quot;text&quot;)
    .attr(&quot;dx&quot;, margin/2.0)
    .attr(&quot;dy&quot;, height/4.0)
    .attr(&quot;font-size&quot;, &quot;14px&quot;)
    .attr(&quot;fill&quot;, fill.range()[16])
    .text(function(){return &quot;Probability of reaching &quot;+kThresh+&quot; in infinitely many steps: &quot;+Math.pow(Math.min(1.0,n_ex/n_in),kThresh);});

  var numFinish = 0;
  var numFail = 0;
  var steps = 0;

  var statistics = svg.append(&quot;text&quot;)
    .attr(&quot;dx&quot;, margin/2.0)
    .attr(&quot;dy&quot;, 3.0*height/4.0)
    .attr(&quot;font-size&quot;, &quot;14px&quot;)
    .attr(&quot;fill&quot;, fill.range()[16])
    .text(function(){return &quot;Number of times we reached &quot;+kThresh+&quot;: &quot;+numFinish;});

  var statistics_fail = svg.append(&quot;text&quot;)
    .attr(&quot;dx&quot;, margin/2.0)
    .attr(&quot;dy&quot;, 3.3*height/4.0)
    .attr(&quot;font-size&quot;, &quot;14px&quot;)
    .attr(&quot;fill&quot;, fill.range()[16])
    .text(function(){return &quot;Number of times we didn't reach &quot;+kThresh+&quot;: &quot;+numFail;});

  var statistics_summary = svg.append(&quot;text&quot;)
    .attr(&quot;dx&quot;, margin/2.0)
    .attr(&quot;dy&quot;, 3.6*height/4.0)
    .attr(&quot;font-size&quot;, &quot;14px&quot;)
    .attr(&quot;fill&quot;, fill.range()[16])
    .text(function(){return &quot;Estimated probability of reaching &quot;+kThresh+&quot; in &quot;+max_steps+&quot; steps: &quot;+numFinish/(Math.max(1,numFail+numFinish));});


  transition(kThresh);

  function transition(state) {
    if(num_exp != trial) {
      return;
    }
    steps += 1;
    if(steps&gt;max_steps) {
      steps = 0;
      d3.select(labels[0][0]).transition().duration(100)
        .text(-kThresh)
      numFail++;
      tick(numFinish/(numFinish+numFail));
      statistics_fail
        .text(function(){return &quot;Number of times we didn't reach &quot;+kThresh+&quot;: &quot;+numFail;});
      statistics_summary
        .text(function(){return &quot;Estimated probability of reaching &quot;+kThresh+&quot; in &quot;+max_steps+&quot; steps: &quot;+numFinish/(numFail+numFinish);});
      transition(kThresh);
      return;
    }
    prob_win
    .text(function(){return &quot;Probability of reaching &quot;+kThresh+&quot; in infinitely many steps: &quot;+Math.pow(Math.min(1.0,n_ex/n_in),2*kThresh-state);});
    if(state &lt;= 0) {
      circle
      .attr(&quot;opacity&quot;,0.1);
    }
    else {
      circle
        .attr(&quot;opacity&quot;,0.5);
    }
    if(state==xs.length-1) {
      histogram_data.push(steps-1);
      //console.log(histogram_data);
      update_histogram();
      numFinish++;
      tick(numFinish/(numFinish+numFail));
      steps = 0;
      statistics
        .text(function(){return &quot;Number of times we reached &quot;+kThresh+&quot;: &quot;+numFinish;});
      statistics_summary
        .text(function(){return &quot;Estimated probability of reaching &quot;+kThresh+&quot; in &quot;+max_steps+&quot; steps: &quot;+numFinish/(numFail+numFinish);});
      transition(kThresh);
      return;
    }
    else if(state&lt;0) {
      d3.select(labels[0][0]).transition().duration(100)
      .text(state-kThresh)
      .attr(&quot;dy&quot;, function(d){
      if (state-kThresh&lt;-9){return 3;}
      else {return 5;}})
      .attr(&quot;font-size&quot;, function() {
      if (state-kThresh&lt;-9){return &quot;10px&quot;;}
      else {return &quot;14px&quot;;}})
      .each(&quot;end&quot;,function() {
        if(Math.random() &lt;= n_in/(n_ex+n_in)) {
          circle.transition()
            .duration(speed)
            .each(&quot;end&quot;, function(){transition(state-1);});
        }
        else {
          circle.transition()
            .duration(speed)
            .each(&quot;end&quot;, function() {transition(state+1);});
            }
       });
    }
    else {
      circle.transition()
      .duration(speed)
      .attr(&quot;transform&quot;, &quot;translate(&quot; + path_collection[state][&quot;node&quot;][&quot;coord&quot;] + &quot;)&quot;)
      .each(&quot;end&quot;,function() {
        if(Math.random() &lt;= n_in/(n_ex+n_in)) {
          if(state &gt; 0) {
            circle.transition()
              .duration(2*speed)
              .attrTween(&quot;transform&quot;, translateAlong(path_collection[state][&quot;backward&quot;].node()))
              .each(&quot;end&quot;, function(){transition(state-1);});
          }
          else {
            transition(state-1);
            return;
          }
        }
        else {
          if(state == 0) {
            d3.select(labels[0][0]).transition().duration(speed)
              .text(state-kThresh);
          }
          circle.transition()
            .duration(2*speed)
            .attrTween(&quot;transform&quot;, translateAlong(path_collection[state][&quot;forward&quot;].node()))
            .each(&quot;end&quot;, function() {transition(state+1);});
            }
       });
    }
  }

  // Returns an attrTween for translating along the specified path element.
  function translateAlong(path) {
    var l = path.getTotalLength();
    return function(d, i, a) {
      return function(t) {
        var p = path.getPointAtLength(t * l);
        return &quot;translate(&quot; + p.x + &quot;,&quot; + p.y + &quot;)&quot;;
      };
    };
  }

  // Histogram of number of steps when process finishes
  // A formatter for counts.
  var margin_hist = {top: 10, right: 30, bottom: 30, left: 30};
  var heightHist = 500;
  var formatCount = d3.format(&quot;,.0f&quot;);
  var svgHist = d3.select(&quot;#hist&quot;).append(&quot;svg&quot;)
    .attr(&quot;width&quot;, width + margin_hist.left + margin_hist.right)
    .attr(&quot;height&quot;, heightHist + margin_hist.top + margin_hist.bottom)
  .append(&quot;g&quot;)
    .attr(&quot;transform&quot;, &quot;translate(&quot; + margin_hist.left + &quot;,&quot; + margin_hist.top + &quot;)&quot;);

  var numbins = max_steps;

  var x_scale = d3.scale.linear()
    .domain([1, max_steps])
    .range([0, width-margin_hist.right]);

  var xAxis = d3.svg.axis()
    .scale(x_scale)
    .orient(&quot;bottom&quot;);
  var bandSize = width/(2*numbins);

  
  function update_histogram() {
    numbins = max_steps;
    bandSize = width/(2*numbins);
    x_scale = d3.scale.linear()
      .domain([1, max_steps])
      .range([0, width-margin_hist.right]);
    xAxis = d3.svg.axis()
      .scale(x_scale)
      .orient(&quot;bottom&quot;);

    svgHist.selectAll(&quot;*&quot;).remove();
    var data_binned = d3.layout.histogram()
      .bins(x_scale.ticks(numbins))
      (histogram_data);
    var y_scale = d3.scale.linear()
      .domain([0, d3.max(data_binned, function(d) { return d.y; })])
      .range([heightHist, 0]);

    var bar = svgHist.selectAll(&quot;.bar&quot;)
      .data(data_binned)
    .enter().append(&quot;g&quot;)
      .attr(&quot;class&quot;, &quot;bar&quot;)
      .attr(&quot;transform&quot;, function(d) { return &quot;translate(&quot; + x_scale(d.x) + &quot;,&quot; + y_scale(d.y) + &quot;)&quot;; });

    bar.append(&quot;rect&quot;)
      .attr(&quot;x&quot;, 1)
      .attr(&quot;width&quot;, width/numbins)
      .attr(&quot;height&quot;, function(d) { return heightHist - y_scale(d.y); });

    bar.append(&quot;text&quot;)
      .attr(&quot;dy&quot;, &quot;.75em&quot;)
      .attr(&quot;y&quot;, 6)
      .attr(&quot;x&quot;, width/(2*max_steps))
      .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
      .text(function(d) { return formatCount(d.y); });

    var visible_axis = svgHist.append(&quot;g&quot;)
      .attr(&quot;transform&quot;, &quot;translate(-&quot; + bandSize + &quot;,&quot; + height + &quot;)&quot;)
      .attr(&quot;class&quot;, &quot;x axis&quot;)
      .attr(&quot;fill&quot;,d3.rgb(fill.range()[17]).darker(1))
      .attr(&quot;transform&quot;, &quot;translate(0,&quot; + heightHist + &quot;)&quot;)
      .call(xAxis)
      .selectAll(&quot;text&quot;)
       .style(&quot;text-anchor&quot;, &quot;start&quot;)
       .attr(&quot;transform&quot;, &quot;translate(&quot; + bandSize + &quot;, 0)&quot;);

  }
  update_histogram();
}

setup(trial);

function change_params() {
    speed = parseInt(document.getElementById('delay').value);
    n_ex = parseInt(document.getElementById('nodeCount').value);
    n_in = parseInt(document.getElementById('inodeCount').value);
    max_steps = parseInt(document.getElementById('maximumSteps').value);
    kThresh = parseInt(document.getElementById('kPerc').value);
    trial++;
    setup(trial);
    return;
}



var margin = {top: 20, right: 20, bottom: 20, left: 80};
var width = d3.select(&quot;#chain&quot;).node().getBoundingClientRect().width;
height = 500 - margin.top - margin.bottom;
var fill2 = d3.scale.category10();
var x = d3.scale.log().base(10)//.linear()
    //.domain([1, n-1])
    .domain([1, 1000])
    .range([0, width-100]);
var y = d3.scale.linear()
    .domain([0, 1])
    .range([height-30, 0]);
var line = d3.svg.line()
    //.x(function(d, i) { return x(i); })
    .x(function(d, i) { return x(d.x); })
    //.y(function(d, i) { return y(d); });
    .y(function(d, i) { return y(d.y); });
var svg = d3.select(&quot;#stats&quot;).append(&quot;svg&quot;)
    .attr(&quot;width&quot;, width)
    .attr(&quot;height&quot;, height+3*margin.bottom)
  .append(&quot;g&quot;)
    .attr(&quot;transform&quot;, &quot;translate(&quot; + margin.left + &quot;,&quot; + margin.top + &quot;)&quot;);
svg.append(&quot;defs&quot;).append(&quot;clipPath&quot;)
    .attr(&quot;id&quot;, &quot;clip&quot;)
  .append(&quot;rect&quot;)
    .attr(&quot;width&quot;, width)
    .attr(&quot;height&quot;, height);
svg.append(&quot;g&quot;)
    .attr(&quot;class&quot;, &quot;x axis&quot;)
    .style(&quot;fill&quot;, d3.rgb(fill.range()[17]).darker(1))
    .attr(&quot;transform&quot;, &quot;translate(0,&quot; + y(0) + &quot;)&quot;)
    .call(d3.svg.axis().ticks(3).scale(x).orient(&quot;bottom&quot;).innerTickSize(-height)
    .outerTickSize(0)
    .tickPadding(10));
svg.append(&quot;g&quot;)
    .attr(&quot;class&quot;, &quot;y axis&quot;)
    .style(&quot;fill&quot;, d3.rgb(fill.range()[17]).darker(1))
    .call(d3.svg.axis().scale(y).orient(&quot;left&quot;).innerTickSize(-width)
    .outerTickSize(0)
    .tickPadding(10));
var graph_path = svg.append(&quot;g&quot;)
    .attr(&quot;clip-path&quot;, &quot;url(#clip)&quot;)
  .append(&quot;path&quot;)
    .datum(data)
    .attr(&quot;class&quot;, &quot;line&quot;)
    .attr(&quot;d&quot;, line)
    .attr(&quot;stroke&quot;,fill2(trial));

svg.append(&quot;text&quot;)
  .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
  .attr(&quot;transform&quot;, &quot;translate(&quot;+ -50.0 +&quot;,&quot;+(height/2)+&quot;)rotate(-90)&quot;)
  .text(&quot;Value&quot;)
  .attr(&quot;fill&quot;,d3.rgb(fill.range()[17]).darker(1));

svg.append(&quot;text&quot;)
  .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
  .attr(&quot;transform&quot;, &quot;translate(&quot;+ ((width-100)/2) +&quot;,&quot;+(height+15)+&quot;)&quot;)
  .text(&quot;Time&quot;)
  .attr(&quot;fill&quot;,d3.rgb(fill.range()[17]).darker(1));

var old_trial = trial;

function tick(new_data) {
  if(old_trial &lt; trial) {
    old_trial = trial;
    graph_path = svg.append(&quot;g&quot;)
    .attr(&quot;clip-path&quot;, &quot;url(#clip)&quot;)
    .append(&quot;path&quot;)
      .datum(data)
      .attr(&quot;class&quot;, &quot;line&quot;)
      .attr(&quot;d&quot;, line)
      .attr(&quot;stroke&quot;,fill2(trial));
  }
  // push a new data point onto the back
  //console.log(new_data);
  var t = data.length;
  data.push({x:t+1,y:new_data});
  //data.push(new_data);
  // redraw the line, and slide it to the left
  graph_path
      .attr(&quot;d&quot;, line)
      .attr(&quot;transform&quot;, null);
    /*.transition()
      .duration(100)
      .ease(&quot;linear&quot;)
      .attr(&quot;transform&quot;, &quot;translate(&quot; + x(-1) + &quot;,0)&quot;);*/
  // pop the old data point off the front
  //data.shift();
}
&lt;/script&gt;

</content>
 </entry>
 
 <entry>
   <title>Percolation with inhibition - part 1</title>
   <link href="http://haffi112.github.io/2016/04/25/percolation-with-inhibition/"/>
   <updated>2016-04-25T00:00:00+00:00</updated>
   <id>http://haffi112.github.io/2016/04/25/percolation-with-inhibition</id>
   <content type="html">&lt;p&gt;In the previous posts we have discussed &lt;a href=&quot;/2016/03/27/bootstrap-percolation/&quot;&gt;synchronous&lt;/a&gt; and &lt;a href=&quot;/2016/04/08/asynchronous-percolation/&quot;&gt;asynchronous&lt;/a&gt; bootstrap percolation, processes
which model the dissemination of information in a graph.&lt;/p&gt;

&lt;p&gt;In these previous models we only studied vertices which could excite
their neighbours. This is a good basic model for the spread of diseases
or gossip. However in other settings we might instead have competing
forces. For instance the messages might represent product
recommendations from friends. If all your friends recommend some brand
you might be triggered to buy it. However, if some of your friends
recommend another you might change your decision on what to buy or
simply be confused. Similarly in the brain some of the neurons are
excitatory and send positive messages while others are inhibitory and
send negative messages. The inhibitory neurons are quite important
because if excitation is abundant the activity can run out of control
which can lead to epileptic seizures.&lt;/p&gt;

&lt;p&gt;Thus it becomes natural to study the question what happens if instead we
allowed some of the nodes to be negative? That is exactly what we did in
&lt;a href=&quot;#einarsson2014bootstrap&quot;&gt;(Einarsson, Lengler, Panagiotou, Mousset, &amp;amp; Steger, 2014)&lt;/a&gt;. We made some interesting observations
which I will highlight in follow up posts.&lt;/p&gt;

&lt;p&gt;Below you can see an implementation of asynchronous bootstrap
percolation with inhibition made with &lt;a href=&quot;https://d3js.org&quot;&gt;d3js&lt;/a&gt;. The
green nodes send positive messages and the red nodes send negative
messages. Each vertex keeps track of how many positive messages it has
seen minus the number of negative vertices. We refer to this as the
&lt;em&gt;potential&lt;/em&gt; of the vertex. A vertex turns active (and remains active) if
its potential ever reaches &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;. You can try to control which fraction
of the green vertices turn active by changing the number of negative
vertices. When the potential of a vertex becomes negative we color the
vertex blue. Vertices which reach this state have a lower chance of ever
turning active. They can but for most of them they are essentially
frozen.&lt;/p&gt;

&lt;div id=&quot;simulation&quot;&gt;
&lt;/div&gt;

&lt;form onsubmit=&quot;create_graph(); return false;&quot; style=&quot;margin-bottom:20px&quot;&gt;
  &lt;input type=&quot;button&quot; value=&quot;Build graph&quot; onclick=&quot;create_graph()&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;Percolate&quot; onclick=&quot;percolate()&quot; /&gt;
  &lt;table style=&quot;max-width: 720px; font-size:75%; margin-bottom:10px&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;nodeCount&quot;&gt;Number of positive vertices (green)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;nodeCount&quot; type=&quot;text&quot; value=&quot;30&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;inodeCount&quot;&gt;Number of negative vertices (red) &lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;inodeCount&quot; type=&quot;text&quot; value=&quot;30&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;nNeighbours&quot;&gt;Expected degree (&lt;i&gt;np&lt;/i&gt;), average number
    of neighbors&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;nNeighbours&quot; type=&quot;text&quot; value=&quot;6&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;kPerc&quot;&gt;Activation threshold (&lt;i&gt;K&lt;/i&gt;)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;kPerc&quot; type=&quot;text&quot; value=&quot;2&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;pBootstrap&quot;&gt;Probability of being in the bootstrap&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;pBootstrap&quot; type=&quot;text&quot; value=&quot;0.2&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;delay&quot;&gt;Expected edge delay (seconds)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;delay&quot; type=&quot;text&quot; value=&quot;1.0&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;p class=&quot;message&quot; id=&quot;message&quot; style=&quot;visibility:hidden;&quot;&gt;

&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;einarsson2014bootstrap&quot;&gt;Einarsson, H., Lengler, J., Panagiotou, K., Mousset, F., &amp;amp; Steger, A. (2014). Bootstrap percolation with inhibition. &lt;i&gt;ArXiv Preprint ArXiv:1410.3291&lt;/i&gt;.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Asynchronous bootstrap percolation</title>
   <link href="http://haffi112.github.io/2016/04/08/asynchronous-percolation/"/>
   <updated>2016-04-08T00:00:00+00:00</updated>
   <id>http://haffi112.github.io/2016/04/08/asynchronous-percolation</id>
   <content type="html">&lt;p&gt;In the &lt;a href=&quot;/2016/03/27/bootstrap-percolation/&quot;&gt;previous post&lt;/a&gt;
we discussed bootstrap percolation, a process which models the
dissemination of information in a graph. In this post we will see a
slight variation of the process. Percolation is traditionally defined to
be round based. However, in reality processes such as rumor spreading,
disease transmission and neural signals are usually not synchronous.
This leads to an asynchronous variant of the process (scroll down if you
are eager to see the visualisation).&lt;/p&gt;

&lt;p&gt;As before, when a vertex turns active, you can think of it as sending a
message to all its neighbours notifying them of its new state (or
infecting them with some disease). The messages do not arrive instantly.
In the synchronous setting  we had to wait for one round until they
arrived, corresponding to a time delay of 1. In the asynchronous setting
these delays can be arbitrary. In &lt;a href=&quot;#einarsson2014bootstrap&quot;&gt;(Einarsson, Lengler, Panagiotou, Mousset, &amp;amp; Steger, 2014)&lt;/a&gt; we
studied for instance the case when all the edges draw their delay from
an exponential distribution with expected delay 1. Recall that as in &lt;a href=&quot;#janson2012bootstrap&quot;&gt;(Janson, Łuczak, Turova, &amp;amp; Vallier, 2012)&lt;/a&gt; we studied the process on &lt;script type=&quot;math/tex&quot;&gt;G_{n,p}&lt;/script&gt;, the
Erdős–Rényi &lt;a href=&quot;https://en.wikipedia.org/wiki/Erdős–Rényi_model&quot;&gt;random
graph&lt;/a&gt; model. As it
turned out, such a slight modification had an interesting quantitative
effect on the process. The activity percolated much faster!&lt;/p&gt;

&lt;p&gt;We showed that asymptotically such a process requires only constant time
in expectation to activate all the vertices whereas the synchronous
process can require up to &lt;script type=&quot;math/tex&quot;&gt;\sim\log\log(np)&lt;/script&gt; rounds in expectation.
This improved speed is due to the fact that once enough many messages
are being delivered almost certainly some of them will be extremely fast
which further fuels the process. You can think of the process in terms
of three phases, the &lt;em&gt;startup phase&lt;/em&gt;, which decides if the activity
survives or not, the &lt;em&gt;explosion phase&lt;/em&gt; where almost all the vertices
turn active (and is the main contributor to the double exponential speed
of the round based process) and finally the &lt;em&gt;clean up phase&lt;/em&gt; where the
last few vertices turn active. In our setting the explosion phase is
instantaneous, formally it takes time &lt;script type=&quot;math/tex&quot;&gt;o(1)&lt;/script&gt; (less than constant) to
activate almost all the vertices (after the initial hurdle of getting
the process started).&lt;/p&gt;

&lt;p&gt;Below you can see an implementation of asynchronous bootstrap
percolation where the expected delay of a message is initially set to
five seconds (you can play with the parameters in the box below, be
warned though, too many vertices can slow down the performance). If you
choose the parameters nicely you will notice that the slow messages are
usually too slow to make any difference. The simulation was made using
&lt;a href=&quot;https://d3js.org&quot;&gt;d3js&lt;/a&gt;. Since javascript is asynchronous it is a
perfect candidate to perform these simulations.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/2016/04/25/percolation-with-inhibition/&quot;&gt;next post&lt;/a&gt; extends this
process with inhibitory vertices.&lt;/p&gt;

&lt;div id=&quot;simulation&quot;&gt;
&lt;/div&gt;

&lt;form onsubmit=&quot;create_graph(); return false;&quot; style=&quot;margin-bottom:20px&quot;&gt;
  &lt;input type=&quot;button&quot; value=&quot;Build graph&quot; onclick=&quot;create_graph()&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;Percolate&quot; onclick=&quot;percolate()&quot; /&gt;
  &lt;table style=&quot;max-width: 720px; font-size:75%; margin-bottom:10px&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;nodeCount&quot;&gt;Number of vertices (&lt;i&gt;n&lt;/i&gt;)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;nodeCount&quot; type=&quot;text&quot; value=&quot;50&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;nNeighbours&quot;&gt;Expected degree (&lt;i&gt;np&lt;/i&gt;), average number
    of neighbors&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;nNeighbours&quot; type=&quot;text&quot; value=&quot;6&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;kPerc&quot;&gt;Activation threshold (&lt;i&gt;K&lt;/i&gt;)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;kPerc&quot; type=&quot;text&quot; value=&quot;2&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;pBootstrap&quot;&gt;Probability of being in the bootstrap&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;pBootstrap&quot; type=&quot;text&quot; value=&quot;0.2&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
    &lt;label for=&quot;delay&quot;&gt;Expected edge delay (seconds)&lt;/label&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;input id=&quot;delay&quot; type=&quot;text&quot; value=&quot;5.0&quot; style=&quot;width: 50px;&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;p class=&quot;message&quot; id=&quot;message&quot; style=&quot;visibility:hidden;&quot;&gt;

&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;einarsson2014bootstrap&quot;&gt;Einarsson, H., Lengler, J., Panagiotou, K., Mousset, F., &amp;amp; Steger, A. (2014). Bootstrap percolation with inhibition. &lt;i&gt;ArXiv Preprint ArXiv:1410.3291&lt;/i&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;janson2012bootstrap&quot;&gt;Janson, S., Łuczak, T., Turova, T., &amp;amp; Vallier, T. (2012). Bootstrap percolation on the random graph  G_ {n, p} . &lt;i&gt;The Annals of Applied Probability&lt;/i&gt;, &lt;i&gt;22&lt;/i&gt;(5), 1989–2047.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Bootstrap percolation</title>
   <link href="http://haffi112.github.io/2016/03/27/bootstrap-percolation/"/>
   <updated>2016-03-27T00:00:00+00:00</updated>
   <id>http://haffi112.github.io/2016/03/27/bootstrap-percolation</id>
   <content type="html">&lt;p&gt;If you have ever heard about
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Percolation&quot; title=&quot;Percolation on
Wikipedia&quot;&gt;percolation&lt;/a&gt;&lt;/em&gt; it might have been in the context of making coffee. That
is, when brewing by filtering water through grinded coffee beans it is a
desireable feature that the water can eventually pass through.
Consequently the particles need to be large enough for the material to
be porous and for the water to &lt;em&gt;percolate&lt;/em&gt; through. This article is not
about brewing coffee unless you want to get really creative but bear in
mind that copious amounts of caffeine were part of its creative process
regardless.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So what kind of percolation are you talking about then? Please explain
like I’m five.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Imagine that your friend just got a new shiny toy. He shows it to you
and you want it. You ask your parents but they say no. In time more of
your friends get the toy and you still want it. Still your parents say
no but they realise this will be a great gift and they buy the toy for
your next birthday.&lt;/p&gt;

&lt;!---
and you express to your parents how your whole mental
model of what is important in the world has radically changed. You
parents resist, you are torn and broken but life goes on. Suddenly more
of your friends get this new toy. The situation becomes different, you
are now a social outcast, your status has been reduced to that of a
pawn. Nobody plays with you anymore, you are a tribe of one, the old
toys are worthless. You are now dressing in black and wearing white make
up. The staff at the kindergarten start getting worried when you start
chanting dark summoning rituals in recess. Eventually, after realising
antidepressants are not an efficient treatment for this condition, your
parents give in to societal pressures and buy you the new toy. The
balance of the world is restored.
--&gt;

&lt;p&gt;You probably already made the connection of how this short example
relates to brewing coffee. If not let me explain. Think of yourself as
an empty cell defined by the finely grained coffee bean particles around
you. If it is not too disturbing you can think of your friends as
adjacent cells. When one of your friends got a new toy in this analogy
their cell was filled with water. For a single adjacent cell full of
water the pressure is not sufficient for the water to enter your cell
but once enough many adjacent cells get filled yours gets filled as
well.&lt;/p&gt;

&lt;p&gt;So you see, percolation has something to do with the dissemination of
information in a network. Some other good examples are gossip and rumor
spreading as well as advertising campaigns – it is important to know
which individuals in a social network one should pay to advertise a
product in order to reach as many potential customers as possible (you
can start throwing your free products at me now). It is also valuable to
know if a banking network is stable and how many individuals need to
default on their loans for the network to collapse &lt;a href=&quot;#amini2014inhomogeneous&quot;&gt;(Amini &amp;amp; Minca, 2014)&lt;/a&gt;. Another great example is the spread of
diseases. For every encounter with an infected individual the chances
of becoming infected increase. My favorite example of bootstrap
percolation is the way neurons communicate in the brain. Neurons
communcate by sending
&lt;a href=&quot;https://en.wikipedia.org/wiki/Neural_coding&quot;&gt;spikes&lt;/a&gt; to their
neighbors. If a neuron receives a couple of spike signals it will also
spike and thus inform all of its neighbors, quite amazing. Finally
percolation can be described by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cellular_automaton&quot;&gt;cellular
automaton&lt;/a&gt; which is
the setting in which it was first studied &lt;a href=&quot;#chalupa1979bootstrap&quot;&gt;(Chalupa, Leath, &amp;amp; Reich, 1979)&lt;/a&gt; (but motivated by physics) and since then it has been extensively
studied on the grid in arbitrarily many dimensions &lt;a href=&quot;#balogh2012sharp&quot;&gt;(Balogh, Bollobás, Duminil-Copin, &amp;amp; Morris, 2012)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you might have realised percolation is literally everywhere around
us. It is therefore not surprising how interest in it has percolated.
Below I will define more formally the process. This is where things
start to get just slightly technical. In case you want to skip the
technical parts just scroll down to the bottom of the article to play
with the javascript simulation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Bootstrap percolation&lt;/em&gt; (also known as iterative retrieval) is a simple
model for the spread of activity in a graph/network. The vertices in the
process have two states, either they are &lt;em&gt;active&lt;/em&gt; or &lt;em&gt;inactive&lt;/em&gt;. The
process traditionally proceeds in rounds. Let &lt;em&gt;K&lt;/em&gt;&amp;gt;0 be a threshold
parameter. In any given round all inactive vertices turn active which
have at least &lt;em&gt;K&lt;/em&gt; active neighbours from previous rounds. Once a vertex
turns active it remains active for the rest of the process. The
&lt;em&gt;bootstrap&lt;/em&gt; just refers to the set of initially active vertices and
&lt;em&gt;percolation&lt;/em&gt; refers to this spread of activity.&lt;/p&gt;

&lt;p&gt;This is the most common definition but there are also some variations of
the process which I will not cover in this post. When a vertex turns
active in the description above you can think of it as the vertex
telling all its neighbours that it turned active and this &lt;em&gt;message&lt;/em&gt;
takes one round to be delivered.&lt;/p&gt;

&lt;p&gt;Generally the process is studied formally on some specific graph classes
where as I mention above the lattice was the first candidate. I’ve been
fortunate to work with some amazing people on a couple of projects
involving bootstrap percolation &lt;a href=&quot;#einarsson2014bootstrap&quot;&gt;(Einarsson, Lengler, Panagiotou, Mousset, &amp;amp; Steger, 2014)&lt;/a&gt; which
will be the topic of a future post. Our study was sparked by the results
by Janson, Luczak, Turova and Vallier &lt;a href=&quot;#janson2012bootstrap&quot;&gt;(Janson, Łuczak, Turova, &amp;amp; Vallier, 2012)&lt;/a&gt;
which analysed bootstrap percolation, the process above, on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Erdős–Rényi_model&quot;&gt;Erdös
Renyi random graph&lt;/a&gt;.
The random graph is quite simple, each edge is present independently
with some probability &lt;em&gt;p&lt;/em&gt; which is a parameter of the model. For &lt;em&gt;n&lt;/em&gt;
vertices the expected number of neighbors is thus &lt;em&gt;np&lt;/em&gt;. Janson et. al
discovered that percolation has a &lt;em&gt;threshold property&lt;/em&gt; on the random
graph. If the bootstrap is below the threshold then almost no additional
vertices turn active. But if it is above the threshold the activity
percolates, that is almost every vertex turns active.&lt;/p&gt;

&lt;p&gt;You can play with the process on the random graph below. The parameters
can be chosen below and additionally you can turn the vertices between
an active and an inactive state by clicking on them. The simulation was
made with &lt;a href=&quot;http://visjs.org&quot;&gt;visjs&lt;/a&gt; and the code is available on my
github page. Please note that at the moment the code scales
quadratically in &lt;em&gt;n&lt;/em&gt; so simulations for large values of &lt;em&gt;n&lt;/em&gt; will be
slow. Additionally the network layout has a hard time converging to a
stable state when there are many vertices and the graph is not sparse.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/2016/04/08/asynchronous-percolation/&quot;&gt;next post&lt;/a&gt;
discusses a variation of the process which is not round based.&lt;/p&gt;

&lt;div id=&quot;mynetwork&quot; style=&quot;max-width: 720px; height: 720px;border: 1px solid lightgray;&quot;&gt;&lt;/div&gt;

&lt;form onsubmit=&quot;draw(); return false;&quot; style=&quot;margin-bottom:20px&quot;&gt;
&lt;table style=&quot;max-width: 720px; font-size:75%; margin-bottom:10px&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;label for=&quot;nodeCount&quot;&gt;Number of vertices (&lt;i&gt;n&lt;/i&gt;)&lt;/label&gt;
  &lt;/td&gt;
  &lt;td&gt;
    &lt;input id=&quot;nodeCount&quot; type=&quot;text&quot; value=&quot;25&quot; style=&quot;width: 50px;&quot; /&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;label for=&quot;nNeighbours&quot;&gt;Expected degree (&lt;i&gt;np&lt;/i&gt;), average number
  of neighbors&lt;/label&gt;
  &lt;/td&gt;
  &lt;td&gt;
    &lt;input id=&quot;nNeighbours&quot; type=&quot;text&quot; value=&quot;5&quot; style=&quot;width: 50px;&quot; /&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;label for=&quot;kPerc&quot;&gt;Activation threshold (&lt;i&gt;K&lt;/i&gt;)&lt;/label&gt;
  &lt;/td&gt;
  &lt;td&gt;
    &lt;input id=&quot;kPerc&quot; type=&quot;text&quot; value=&quot;2&quot; style=&quot;width: 50px;&quot; /&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;label for=&quot;pBootstrap&quot;&gt;Probability of being in the bootstrap&lt;/label&gt;
  &lt;/td&gt;
  &lt;td&gt;
    &lt;input id=&quot;pBootstrap&quot; type=&quot;text&quot; value=&quot;0.2&quot; style=&quot;width: 50px;&quot; /&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;label for=&quot;timeStep&quot;&gt;Time step length in milliseconds (1000 &lt;i&gt;ms&lt;/i&gt; = 1 second)&lt;/label&gt;
  &lt;/td&gt;
  &lt;td&gt;
    &lt;input id=&quot;timeStep&quot; type=&quot;text&quot; value=&quot;1000&quot; style=&quot;width: 50px;&quot; /&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
  &lt;input type=&quot;button&quot; value=&quot;Build graph&quot; onclick=&quot;draw()&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;Percolate&quot; onclick=&quot;percolate()&quot; /&gt;
&lt;/form&gt;

&lt;p class=&quot;message&quot; id=&quot;message&quot; style=&quot;visibility:hidden;&quot;&gt;

&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;http://www2.compute.dtu.dk/~guei/&quot;&gt;Guðmundur&lt;/a&gt; for reading a
draft of this post.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;amini2014inhomogeneous&quot;&gt;Amini, H., &amp;amp; Minca, A. (2014). Inhomogeneous Financial Networks and Contagious Links. &lt;i&gt;Available at SSRN&lt;/i&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;chalupa1979bootstrap&quot;&gt;Chalupa, J., Leath, P. L., &amp;amp; Reich, G. R. (1979). Bootstrap percolation on a Bethe lattice. &lt;i&gt;Journal of Physics C: Solid State Physics&lt;/i&gt;, &lt;i&gt;12&lt;/i&gt;(1), L31.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;balogh2012sharp&quot;&gt;Balogh, J., Bollobás, B., Duminil-Copin, H., &amp;amp; Morris, R. (2012). The sharp threshold for bootstrap percolation in all dimensions. &lt;i&gt;Transactions of the American Mathematical Society&lt;/i&gt;, &lt;i&gt;364&lt;/i&gt;(5), 2667–2701.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;einarsson2014bootstrap&quot;&gt;Einarsson, H., Lengler, J., Panagiotou, K., Mousset, F., &amp;amp; Steger, A. (2014). Bootstrap percolation with inhibition. &lt;i&gt;ArXiv Preprint ArXiv:1410.3291&lt;/i&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;janson2012bootstrap&quot;&gt;Janson, S., Łuczak, T., Turova, T., &amp;amp; Vallier, T. (2012). Bootstrap percolation on the random graph  G_ {n, p} . &lt;i&gt;The Annals of Applied Probability&lt;/i&gt;, &lt;i&gt;22&lt;/i&gt;(5), 1989–2047.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;

</content>
 </entry>
 

</feed>
